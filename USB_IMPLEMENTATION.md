# USB Serial Port Implementation Guide

## Overview
The Papilio Arcade Board has USB data lines connected to the FPGA:
- USB D+ at pin G11
- USB D- at pin H12

## Integration Options

### Option 1: TinyFPGA USB Bootloader (Recommended) ⭐

**Quick Start - Automated Download:**
```powershell
.\download_tinyfpga_usb.ps1
```

This will download all required files to `src/tinyfpga_usb/`

**Manual Download:**
If you prefer to download manually or the script fails, clone the repository:
```bash
git clone https://github.com/tinyfpga/TinyFPGA-Bootloader.git
```

Then copy these files from `TinyFPGA-Bootloader/common/` to `src/tinyfpga_usb/`:
- `usb_fs_pe.v` - Protocol Engine coordinator
- `usb_fs_rx.v` - USB RX (NRZI decoder, packet parser)  
- `usb_fs_tx.v` - USB TX (NRZI encoder, packet builder)
- `usb_fs_in_pe.v` - IN endpoint protocol engine
- `usb_fs_out_pe.v` - OUT endpoint protocol engine
- `usb_fs_in_arb.v` - IN endpoint arbiter
- `usb_fs_out_arb.v` - OUT endpoint arbiter
- `usb_fs_tx_mux.v` - TX packet multiplexer
- `usb_serial_ctrl_ep.v` - CDC-ACM control endpoint

**After Download:**
The files will be automatically added to the project build.

### Option 2: LiteX USB Core
LiteX provides a more feature-complete USB stack with CDC-ACM support.

**Files needed from https://github.com/enjoy-digital/valentyusb:**
```
valentyusb/
  usbcore/
    sm/
      transfer.py → convert to Verilog
    rx/
      pipeline.py → convert to Verilog
    tx/
      pipeline.py → convert to Verilog
  usb/
    cdc.py → convert to Verilog
```

**Note:** LiteX uses Migen/LiteX Python, needs conversion to Verilog using:
```bash
python3 generate.py
```

### Option 3: Custom Minimal Implementation
For a minimal working implementation, you need:

1. **USB PHY** - NRZI encode/decode, bit stuffing
2. **USB Protocol** - Packet handling, CRC5/CRC16
3. **USB Device** - Enumeration, descriptor handling
4. **CDC-ACM Class** - Serial port abstraction

This is 2000-3000 lines of Verilog code.

## Current Implementation Status

### Completed:
- ✅ Wishbone interface wrapper (`usb_serial_wishbone.v`)
- ✅ 48MHz PLL for USB timing (`usb_pll.v`)
- ✅ Pin assignments (G11, H12)
- ✅ Loopback stub for testing

### TODO:
- ⏳ Integrate TinyFPGA or LiteX USB core
- ⏳ Add USB descriptors
- ⏳ Test enumeration
- ⏳ Verify CDC-ACM communication

## Quick Start (with stub)

The current implementation includes a loopback stub for testing the Wishbone interface:

**Register Map (Wishbone Slave 2: 0x20-0x2F):**
- `0x20`: TX data (write) / RX data (read)
- `0x21`: Status
  - Bit 0: rx_valid (data available to read)
  - Bit 1: tx_ready (ready to transmit)
  - Bit 7: usb_connected
- `0x22`: Control
  - Bit 0: USB enable

**Test from ESP32:**
```cpp
// Write data
wishboneWrite8(0x20, 'H');
wishboneWrite8(0x20, 'i');

// Check status
uint8_t status = wishboneRead8(0x21);
if (status & 0x01) {  // rx_valid
    uint8_t data = wishboneRead8(0x20);  // Read echoed data
}
```

## Hardware Requirements

- 48MHz clock (generated by PLL from 27MHz)
- 1.5kΩ pullup on D+ for Full Speed device identification
- USB data lines must support 3.3V signaling

## References

- [USB 1.1 Specification](https://www.usb.org/document-library/usb-11-specification)
- [TinyFPGA Bootloader](https://github.com/tinyfpga/TinyFPGA-Bootloader)
- [ValentyUSB (LiteX)](https://github.com/enjoy-digital/valentyusb)
- [USB Made Simple](http://www.usbmadesimple.co.uk/)
