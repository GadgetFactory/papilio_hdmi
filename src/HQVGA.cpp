/*
 * HQVGA Library for ESP32-S3
 * 
 * Original HQVGA VGA controller by Alvaro Lopes <alvieboy@alvie.com>
 * ESP32-S3 port by Jack Gassett, Gadget Factory
 * 
 * Ported from ZPUINO direct memory access to Wishbone-over-SPI for ESP32-S3
 */

#include "HQVGA.h"
#include <pgmspace.h>

#define ABS(x) ((x)>0?(x):-1*(x))

// Basic 8x8 font - ASCII 32-127 (96 characters)
// Each character is 8 bytes, one per row, MSB is leftmost pixel
static const uint8_t font8x8[] PROGMEM = {
    // Space (32)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // ! (33)
    0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00,
    // " (34)
    0x6C, 0x6C, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00,
    // # (35)
    0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00,
    // $ (36)
    0x18, 0x7E, 0xC0, 0x7C, 0x06, 0xFC, 0x18, 0x00,
    // % (37)
    0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00,
    // & (38)
    0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00,
    // ' (39)
    0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
    // ( (40)
    0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00,
    // ) (41)
    0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00,
    // * (42)
    0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00,
    // + (43)
    0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00,
    // , (44)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30,
    // - (45)
    0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,
    // . (46)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
    // / (47)
    0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00,
    // 0 (48)
    0x7C, 0xCE, 0xDE, 0xF6, 0xE6, 0xC6, 0x7C, 0x00,
    // 1 (49)
    0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00,
    // 2 (50)
    0x7C, 0xC6, 0x06, 0x1C, 0x70, 0xC6, 0xFE, 0x00,
    // 3 (51)
    0x7C, 0xC6, 0x06, 0x3C, 0x06, 0xC6, 0x7C, 0x00,
    // 4 (52)
    0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x1E, 0x00,
    // 5 (53)
    0xFE, 0xC0, 0xFC, 0x06, 0x06, 0xC6, 0x7C, 0x00,
    // 6 (54)
    0x38, 0x60, 0xC0, 0xFC, 0xC6, 0xC6, 0x7C, 0x00,
    // 7 (55)
    0xFE, 0xC6, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00,
    // 8 (56)
    0x7C, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0x7C, 0x00,
    // 9 (57)
    0x7C, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0x78, 0x00,
    // : (58)
    0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00,
    // ; (59)
    0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30,
    // < (60)
    0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x00,
    // = (61)
    0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00,
    // > (62)
    0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00,
    // ? (63)
    0x7C, 0xC6, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x00,
    // @ (64)
    0x7C, 0xC6, 0xDE, 0xDE, 0xDC, 0xC0, 0x7C, 0x00,
    // A (65)
    0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0x00,
    // B (66)
    0xFC, 0xC6, 0xC6, 0xFC, 0xC6, 0xC6, 0xFC, 0x00,
    // C (67)
    0x7C, 0xC6, 0xC0, 0xC0, 0xC0, 0xC6, 0x7C, 0x00,
    // D (68)
    0xF8, 0xCC, 0xC6, 0xC6, 0xC6, 0xCC, 0xF8, 0x00,
    // E (69)
    0xFE, 0xC0, 0xC0, 0xFC, 0xC0, 0xC0, 0xFE, 0x00,
    // F (70)
    0xFE, 0xC0, 0xC0, 0xFC, 0xC0, 0xC0, 0xC0, 0x00,
    // G (71)
    0x7C, 0xC6, 0xC0, 0xCE, 0xC6, 0xC6, 0x7E, 0x00,
    // H (72)
    0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00,
    // I (73)
    0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00,
    // J (74)
    0x1E, 0x06, 0x06, 0x06, 0xC6, 0xC6, 0x7C, 0x00,
    // K (75)
    0xC6, 0xCC, 0xD8, 0xF0, 0xD8, 0xCC, 0xC6, 0x00,
    // L (76)
    0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xFE, 0x00,
    // M (77)
    0xC6, 0xEE, 0xFE, 0xD6, 0xC6, 0xC6, 0xC6, 0x00,
    // N (78)
    0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00,
    // O (79)
    0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
    // P (80)
    0xFC, 0xC6, 0xC6, 0xFC, 0xC0, 0xC0, 0xC0, 0x00,
    // Q (81)
    0x7C, 0xC6, 0xC6, 0xC6, 0xD6, 0xDE, 0x7C, 0x06,
    // R (82)
    0xFC, 0xC6, 0xC6, 0xFC, 0xD8, 0xCC, 0xC6, 0x00,
    // S (83)
    0x7C, 0xC6, 0xC0, 0x7C, 0x06, 0xC6, 0x7C, 0x00,
    // T (84)
    0xFE, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00,
    // U (85)
    0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
    // V (86)
    0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00,
    // W (87)
    0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00,
    // X (88)
    0xC6, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0xC6, 0x00,
    // Y (89)
    0xC6, 0xC6, 0x6C, 0x38, 0x18, 0x18, 0x18, 0x00,
    // Z (90)
    0xFE, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xFE, 0x00,
    // [ (91)
    0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00,
    // \ (92)
    0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00,
    // ] (93)
    0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00,
    // ^ (94)
    0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // _ (95)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE,
    // ` (96)
    0x18, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00,
    // a (97)
    0x00, 0x00, 0x7C, 0x06, 0x7E, 0xC6, 0x7E, 0x00,
    // b (98)
    0xC0, 0xC0, 0xFC, 0xC6, 0xC6, 0xC6, 0xFC, 0x00,
    // c (99)
    0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC6, 0x7C, 0x00,
    // d (100)
    0x06, 0x06, 0x7E, 0xC6, 0xC6, 0xC6, 0x7E, 0x00,
    // e (101)
    0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0x7C, 0x00,
    // f (102)
    0x1C, 0x36, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x00,
    // g (103)
    0x00, 0x00, 0x7E, 0xC6, 0xC6, 0x7E, 0x06, 0x7C,
    // h (104)
    0xC0, 0xC0, 0xFC, 0xC6, 0xC6, 0xC6, 0xC6, 0x00,
    // i (105)
    0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00,
    // j (106)
    0x06, 0x00, 0x0E, 0x06, 0x06, 0x66, 0x66, 0x3C,
    // k (107)
    0xC0, 0xC0, 0xC6, 0xCC, 0xF8, 0xCC, 0xC6, 0x00,
    // l (108)
    0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00,
    // m (109)
    0x00, 0x00, 0xEC, 0xFE, 0xD6, 0xC6, 0xC6, 0x00,
    // n (110)
    0x00, 0x00, 0xFC, 0xC6, 0xC6, 0xC6, 0xC6, 0x00,
    // o (111)
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
    // p (112)
    0x00, 0x00, 0xFC, 0xC6, 0xC6, 0xFC, 0xC0, 0xC0,
    // q (113)
    0x00, 0x00, 0x7E, 0xC6, 0xC6, 0x7E, 0x06, 0x06,
    // r (114)
    0x00, 0x00, 0xDC, 0xE6, 0xC0, 0xC0, 0xC0, 0x00,
    // s (115)
    0x00, 0x00, 0x7E, 0xC0, 0x7C, 0x06, 0xFC, 0x00,
    // t (116)
    0x30, 0x30, 0x7C, 0x30, 0x30, 0x36, 0x1C, 0x00,
    // u (117)
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0x7E, 0x00,
    // v (118)
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00,
    // w (119)
    0x00, 0x00, 0xC6, 0xC6, 0xD6, 0xFE, 0x6C, 0x00,
    // x (120)
    0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00,
    // y (121)
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x7C,
    // z (122)
    0x00, 0x00, 0xFE, 0x0C, 0x38, 0x60, 0xFE, 0x00,
    // { (123)
    0x0E, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0E, 0x00,
    // | (124)
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00,
    // } (125)
    0x70, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x70, 0x00,
    // ~ (126)
    0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // DEL (127) - filled block
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
};

VGA_class::VGA_class() 
	: _spi(nullptr), _ownSpi(false), _cs(10), _clk(12), _mosi(11), _miso(9),
	  _wbBase(HQVGA_WISHBONE_BASE), fg(WHITE), bg(BLACK), 
	  blitOffset(0), blitw(0), cblit(0) {
}

VGA_class::~VGA_class() {
	if (_ownSpi && _spi) {
		delete _spi;
	}
}

void VGA_class::begin(SPIClass* spi, uint8_t csPin, uint8_t spiClk, 
                      uint8_t spiMosi, uint8_t spiMiso, uint8_t wishboneBase) {
	_cs = csPin;
	_clk = spiClk;
	_mosi = spiMosi;
	_miso = spiMiso;
	_wbBase = wishboneBase;
	
	if (spi == nullptr) {
		_spi = new SPIClass(HSPI);
		_ownSpi = true;
		_spi->begin(_clk, _miso, _mosi, _cs);
	} else {
		_spi = spi;
		_ownSpi = false;
	}
	
	pinMode(_cs, OUTPUT);
	digitalWrite(_cs, HIGH);
	
	// Wait for FPGA to configure and verify framebuffer mode is set
	// Keep trying until we successfully read back mode 2
	const unsigned long timeout = 5000;  // 5 second timeout
	unsigned long startTime = millis();
	
	while (millis() - startTime < timeout) {
		delay(100);  // Small delay between attempts
		setVideoMode(2);
		delay(10);   // Let the write complete
		
		uint8_t mode = getVideoMode();
		if (mode == 2) {
			// Successfully set framebuffer mode
			return;
		}
	}
	// Timeout - FPGA may not be ready or communication issue
}

uint8_t VGA_class::getVideoMode() {
	// Read from video mode control register at address 0x0000
	digitalWrite(_cs, LOW);
	delayMicroseconds(1);
	
	_spi->transfer(0x00);  // CMD: Read command
	_spi->transfer(0x00);  // ADDR_HIGH: 0x00
	_spi->transfer(0x00);  // ADDR_LOW: 0x00
	uint8_t mode = _spi->transfer(0x00);  // DATA: read result
	
	delayMicroseconds(1);
	digitalWrite(_cs, HIGH);
	delayMicroseconds(5);
	
	return mode & 0x03;
}

void VGA_class::setVideoMode(uint8_t mode) {
	// Write to video mode control register at address 0x0000
	// Mode values: 0=TestPattern, 1=Text, 2=Framebuffer
	digitalWrite(_cs, LOW);
	delayMicroseconds(1);
	
	_spi->transfer(0x01);  // CMD: Write command
	_spi->transfer(0x00);  // ADDR_HIGH: 0x00
	_spi->transfer(0x00);  // ADDR_LOW: 0x00
	_spi->transfer(mode & 0x03);  // DATA: video mode (0-2)
	
	delayMicroseconds(1);
	digitalWrite(_cs, HIGH);
	delayMicroseconds(5);
}

void VGA_class::writeWishbone(uint16_t addr, uint8_t data) {
	// HQVGA frame buffer: pixel address 0-19199 (160x120)
	// Framebuffer starts at address 0x0100 in the Wishbone address map
	// 4-byte SPI protocol: CMD | ADDR_HIGH | ADDR_LOW | DATA
	
	uint16_t wb_addr = 0x0100 + addr;  // Framebuffer base + pixel offset
	
	digitalWrite(_cs, LOW);
	delayMicroseconds(1);
	
	// Send 4-byte write transaction
	_spi->transfer(0x01);                     // CMD: Write command
	_spi->transfer((wb_addr >> 8) & 0xFF);    // ADDR_HIGH: bits [15:8]
	_spi->transfer(wb_addr & 0xFF);           // ADDR_LOW: bits [7:0]
	_spi->transfer(data);                     // DATA: pixel data
	
	delayMicroseconds(1);
	digitalWrite(_cs, HIGH);
	delayMicroseconds(5);
}

uint8_t VGA_class::readWishbone(uint16_t addr) {
	// HQVGA frame buffer: pixel address 0-19199 (160x120)
	// Framebuffer starts at address 0x0100 in the Wishbone address map
	// 4-byte SPI protocol: CMD | ADDR_HIGH | ADDR_LOW | DATA
	
	uint16_t wb_addr = 0x0100 + addr;  // Framebuffer base + pixel offset
	
	digitalWrite(_cs, LOW);
	delayMicroseconds(1);
	
	// Send 4-byte read transaction
	_spi->transfer(0x00);                     // CMD: Read command (0x00, not 0x02!)
	_spi->transfer((wb_addr >> 8) & 0xFF);    // ADDR_HIGH: bits [15:8]
	_spi->transfer(wb_addr & 0xFF);           // ADDR_LOW: bits [7:0]
	uint8_t result = _spi->transfer(0x00);    // DATA: read result
	
	delayMicroseconds(1);
	digitalWrite(_cs, HIGH);
	delayMicroseconds(5);
	
	return result;
}

void VGA_class::putPixel(int x, int y) {
	putPixel(x, y, fg);
}

void VGA_class::putPixel(int x, int y, pixel_t color) {
	if (x < 0 || x >= (int)VGA_HSIZE || y < 0 || y >= (int)VGA_VSIZE)
		return;
	
	uint16_t offset = getOffset(x, y);
	writeWishbone(offset, color);
}

VGA_class::pixel_t VGA_class::getPixel(int x, int y) {
	if (x < 0 || x >= (int)VGA_HSIZE || y < 0 || y >= (int)VGA_VSIZE)
		return 0;
	
	uint16_t offset = getOffset(x, y);
	return readWishbone(offset);
}

void VGA_class::clear() {
	// Clear entire screen to background color
	pixel_t oldFg = fg;
	fg = bg;
	drawRect(0, 0, VGA_HSIZE, VGA_VSIZE);
	fg = oldFg;
}

void VGA_class::clearArea(unsigned x, unsigned y, unsigned width, unsigned height) {
	pixel_t oldFg = fg;
	fg = bg;
	drawRect(x, y, width, height);
	fg = oldFg;
}

void VGA_class::drawRect(unsigned x, unsigned y, unsigned width, unsigned height) {
	for (unsigned h = 0; h < height; h++) {
		for (unsigned w = 0; w < width; w++) {
			putPixel(x + w, y + h, fg);
		}
	}
}

void VGA_class::printchar(unsigned int x, unsigned int y, unsigned char c, bool trans) {
	// Character rendering using built-in 8x8 font
	// Font covers ASCII 32-127 (96 characters)
	
	// Clamp character to valid font range
	if (c < 32 || c > 127) {
		c = '?';  // Replace invalid characters with ?
	}
	
	// Get font data pointer for this character
	const uint8_t *charData = &font8x8[(c - 32) * 8];
	
	for (int cy = 0; cy < 8; cy++) {
		uint8_t rowBits = pgm_read_byte(&charData[cy]);
		
		for (int cx = 0; cx < 8; cx++) {
			int px = x + cx;
			int py = y + cy;
			
			if (px >= 0 && px < (int)VGA_HSIZE && py >= 0 && py < (int)VGA_VSIZE) {
				// MSB is leftmost pixel
				bool pixelOn = (rowBits >> (7 - cx)) & 0x01;
				
				if (pixelOn) {
					putPixel(px, py, fg);
				} else if (!trans) {
					putPixel(px, py, bg);
				}
			}
		}
	}
}

void VGA_class::printtext(unsigned x, unsigned y, const char *text, bool trans) {
	while (*text) {
		printchar(x, y, *text, trans);
		text++;
		x += 8;
	}
}

void VGA_class::readArea(int x, int y, int width, int height, pixel_t *dest) {
	for (int h = 0; h < height; h++) {
		for (int w = 0; w < width; w++) {
			*dest++ = getPixel(x + w, y + h);
		}
	}
}

void VGA_class::writeArea(int x, int y, int width, int height, pixel_t *source) {
	for (int h = 0; h < height; h++) {
		for (int w = 0; w < width; w++) {
			putPixel(x + w, y + h, *source++);
		}
	}
}

void VGA_class::moveArea(unsigned x, unsigned y, unsigned width, unsigned height, unsigned tx, unsigned ty) {
	// Use temporary buffer for move operation
	pixel_t *buffer = new pixel_t[width * height];
	if (!buffer) return;
	
	readArea(x, y, width, height, buffer);
	writeArea(tx, ty, width, height, buffer);
	
	delete[] buffer;
}

void VGA_class::blitStreamInit(int x, int y, int w) {
	blitOffset = getOffset(x, y);
	blitw = w;
	cblit = 0;
}

void VGA_class::blitStreamAppend(unsigned char c) {
	uint16_t offset = blitOffset + cblit;
	uint16_t x = offset % VGA_HSIZE;
	uint16_t y = offset / VGA_HSIZE;
	putPixel(x, y, c);
	
	cblit++;
	if (cblit == blitw) {
		cblit = 0;
		blitOffset += VGA_HSIZE;
	}
}

void VGA_class::drawLine(int x0, int y0, int x1, int y1) {
	int dx = ABS(x1 - x0);
	int dy = ABS(y1 - y0);
	int sx = (x0 < x1) ? 1 : -1;
	int sy = (y0 < y1) ? 1 : -1;
	int err = dx - dy;
	int x = x0;
	int y = y0;
	
	while (true) {
		putPixel(x, y, fg);
		
		if (x == x1 && y == y1)
			break;
		
		int e2 = 2 * err;
		if (e2 > -dy) {
			err -= dy;
			x += sx;
		}
		if (e2 < dx) {
			err += dx;
			y += sy;
		}
	}
}

VGA_class VGA;
